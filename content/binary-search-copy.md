---
category: notes
title: Бинарный поиск (Binary search)
description: 
date: 2021-04-10
tags:
  - js
  - алгоритмы
  - задачи
  - база
---
Получаем отсортированный массив. На каждом шаге сужаем зону поиска в двое, отбрасывая часть в которой **точно нет** (благодаря сортировке) нужного результата.

Например, у нас есть массив с числами от `1` до `13`. Загадаем число `5`. Находим значение в середине массива `7`. `5 < 7`, а так как массив отсортирован, уже нет смысла искать в правой части. **Сократили в 2 раза** зону поиска одной проверкой! Далее ищем в промежутке от `1` до `6`. Значение из середины `3`. `5 > 3`, значит может отбросить левую часть. Остаётся проверить промежуток от `4` до `6`. Находим центр = `5` — отлично, мы наткнулись на искомый элемент, возвращаем его индекс.

```text
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
                   ┃
[1, 2, 3, 4, 5, 6, _, _, _, __, __, __, __]
       ┃              
[_, _, _, 4, 5, 6, _, _, _, __, __, __, __]
             ┃
             5 (возвращаем индекс 4)
```

## Сложность

`O(log n)` — логарифмическая сложность

## JS

```js
function binarySearch(sortedArray, item) {
  let start = 0;
  let end = sortedArray.length - 1;

  while (start <= end) {
    // Находим середину
    const middle = Math.floor((start + end) / 2);

    // Если результат оказался в середине
    if (item === sortedArray[middle]) {
      // Возвращаем найденное значение
      return middle;
    }

    // Если искомое значение меньше значения в середине
    if (item < sortedArray[middle]) {
      // Исключаем правую часть
      end = middle - 1;
    // Если больше
    } else {
      // Исключаем правую часть
      start = middle + 1;
    }
  }

  // Если не найдено, возвращаем -1
  return -1;
}

const arr = [1, 3, 7, 22, 91];

binarySearch(arr, 3); //= 1
binarySearch(arr, 22); //= 3
binarySearch(arr, 91); //= 4
binarySearch(arr, 42); //= -1
```

## Сомнения

Кажется, что сортировка массива слишком дорогая операция, в бинарном поиске точно есть смысл?

Есть. Например, если у нас поисков много, мы может предварительно отсортировать массив единожды.

## Упражнения

1. Имеется список из `128` отсортированных имён. Сколько проверок понадобится бинарному поиску?

    <details>
      <summary>Ответ</summary>

      `log₂128 = 7`
    </details>

2. Размер списка со `128` увеличился в `2` раза. Сколько проверок нужно теперь?

    <details>
      <summary>Ответ</summary>

      Так как на каждой проверке мы уменьшаем зону поиска в 2 раза, очевидно предположить, что при увеличении списка в 2 раза понадобится `+1` проверка. `log₂256 = 8`
    </details>
